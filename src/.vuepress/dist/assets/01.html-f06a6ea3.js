import{_ as e,r as t,o as p,c as o,a as c,b as n,e as i,w as l,f as s}from"./app-a2c27636.js";const r={},d=s(`<h2 id="_2-1-1-表-list-和-元组-tuple" tabindex="-1"><a class="header-anchor" href="#_2-1-1-表-list-和-元组-tuple" aria-hidden="true">#</a> 2.1.1 表（List）和 元组（tuple）</h2><p>表和元组只有一点差别：<strong>表是可以更新的，但是元组在创建之后就不能修改了。</strong></p><p>因此，在使用过程中，如果被记录的数据需要更新，则使用表更合适；否则使用元组更合适。</p><h2 id="_2-1-2-可迭代对象" tabindex="-1"><a class="header-anchor" href="#_2-1-2-可迭代对象" aria-hidden="true">#</a> 2.1.2 可迭代对象</h2><p>表的创建经常会使用到<code>list</code>函数，而该函数的实参应当是序列或者<strong>迭代器</strong>。而迭代器和序列统称为<strong>可迭代对象</strong>。</p><p>所以，什么是「迭代器」？</p><p>在 python 中，一个类如果实现了<strong>迭代器协议</strong>，就可以称之为「迭代器」。</p><p>在 Python 中，实现迭代器协议就是实现以下 2 个方法：</p><ul><li><code>__iter__</code>：这个方法返回对象本身，即 self</li><li><code>__next__</code>：这个方法每次返回迭代的值，在没有可迭代元素时，抛出 StopIteration 异常</li></ul><p>进而，我们可以对「可迭代对象」进行定义。</p><ul><li><code>__iter__</code> 方法返回一个迭代器，那么这个对象就是「可迭代对象」</li></ul><p>下面是一个例子：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
    <span class="token comment"># A是迭代器 因为它实现了 __iter__ 和__next__方法</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>idx <span class="token operator">=</span> <span class="token number">0</span>
        self<span class="token punctuation">.</span>n <span class="token operator">=</span> n

    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self

    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>idx <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>n<span class="token punctuation">:</span>
            val <span class="token operator">=</span> self<span class="token punctuation">.</span>idx
            self<span class="token punctuation">.</span>idx <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">return</span> val
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> StopIteration<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span>
    <span class="token comment"># B不是迭代器 但B的实例是一个可迭代对象</span>
    <span class="token comment"># 因为它只实现了 __iter__</span>
    <span class="token comment"># __iter__返回了A的实例 迭代细节交给了A</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>n <span class="token operator">=</span> n

    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> A<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n<span class="token punctuation">)</span>

<span class="token comment"># a是一个迭代器 同时也是一个可迭代对象</span>
a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token comment"># &lt;__main__.A object at 0x10eb95550&gt;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># b不是迭代器 但它是可迭代对象 因为它把迭代细节交给了A</span>
b <span class="token operator">=</span> B<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> b<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token comment"># &lt;__main__.A object at 0x10eb95450&gt;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子说明，一个类的迭代细节，是可以交给另一个类的，就像这个例子的 B 这样，所以 B 的实例只能是「可迭代对象」，而不是「迭代器」。</p><p>其实，这种情况我们见的非常多，我们使用最多的 <code>list</code>、<code>tuple</code>、<code>set</code>、<code>dict</code> 类型，都只是「可迭代对象」，但不是「迭代器」，因为它们都是把迭代细节交给了另外一个类，这个类才是真正的迭代器。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>与之区别的概念，还有 <strong>生成器</strong>。</p><p>「生成器」是一个特殊的「迭代器」，并且它也是一个「可迭代对象」。</p><p>有 2 种方式可以创建一个生成器：</p><ul><li>生成器表达式</li><li>生成器函数</li></ul><p>用生成器表达式创建一个生成器的例子如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建一个生成器 类型是 generator</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> g <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">))</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> g
<span class="token operator">&lt;</span>generator object <span class="token operator">&lt;</span>genexpr<span class="token operator">&gt;</span> at 0x101334f5<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>
<span class="token comment"># 生成器就是一个迭代器</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> iter<span class="token punctuation">(</span>g<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>generator object <span class="token operator">&lt;</span>genexpr<span class="token operator">&gt;</span> at 0x101334f5<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>
<span class="token comment"># 生成器也是一个可迭代对象</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> g:
<span class="token punctuation">..</span>.     print<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token comment"># 0 1 2 3 4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来看用函数创建一个生成器:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>def gen<span class="token punctuation">(</span>n<span class="token punctuation">)</span>:
    <span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span>:
        yield i

<span class="token comment"># 创建一个生成器</span>
g <span class="token operator">=</span> gen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token comment"># &lt;generator object gen at 0x10bb46f50&gt;</span>
print<span class="token punctuation">(</span>g<span class="token punctuation">)</span>
<span class="token comment"># &lt;type &#39;generator&#39;&gt;</span>
print<span class="token punctuation">(</span>type<span class="token punctuation">(</span>g<span class="token punctuation">))</span>

<span class="token comment"># 迭代这个生成器</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> g:
    print<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token comment"># 0 1 2 3 4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实，包含 <code>yield</code> 关键字的函数，不再是一个普通的函数，而返回的是一个生成器。它在功能上与上面的例子一样，可以迭代生成器中的所有数据。</p><p>通常情况下，我们习惯在函数内使用 <code>yield</code> 的方式来创建一个生成器。</p><p>但是，使用生成器迭代数据相比于普通方式迭代数据，有什么优势呢？</p><p>这就要来看一下使用 <code>yield</code> 的函数和使用 <code>return</code> 的普通函数，有什么区别了。使用 <code>yield</code> 的函数与使用 <code>return</code> 的函数，在执行时的差别在于：</p><ul><li>包含 <code>return</code> 的方法会以 <code>return</code> 关键字为最终返回，每次执行都返回相同的结果。</li><li>包含 <code>yield</code> 的方法一般用于迭代，每次执行时遇到 <code>yield</code> 就返回 <code>yield</code> 后的结果，但内部会保留上次执行的状态，下次继续迭代时，会继续执行 <code>yield</code> 之后的代码，直到再次遇到 <code>yield</code> 后返回</li></ul><p><strong>这种方法相对于 <code>[i for i in range(n)]</code> 可以节约非常多的内存，可以解决内存占用大的问题。</strong></p></div><h2 id="_2-1-3-表的处理" tabindex="-1"><a class="header-anchor" href="#_2-1-3-表的处理" aria-hidden="true">#</a> 2.1.3 表的处理</h2><h3 id="a-遍历" tabindex="-1"><a class="header-anchor" href="#a-遍历" aria-hidden="true">#</a> a.遍历</h3><p>对于<code>List</code>对象而言，在使用 <code>for</code> 循环的时候不能修改表的元素的，否则会导致整体循环的改变。</p>`,19),u=s(`<h3 id="b-高阶函数" tabindex="-1"><a class="header-anchor" href="#b-高阶函数" aria-hidden="true">#</a> b. 高阶函数</h3><p>在实现表到表之间的高阶映射或者一些表之间的计算的过程中，可以采用 <strong>函数式编程</strong> 的方式来进行处理。<code>map-reduce</code> 就是其中的一个典型方法。通过标准函数 <code>map</code> ，可以得到一个序列到另一个序列的映射的迭代器，有关内容会在第三章进行介绍</p><p>链接：<mark>写了再贴上</mark></p><h2 id="_2-1-4-元组的处理" tabindex="-1"><a class="header-anchor" href="#_2-1-4-元组的处理" aria-hidden="true">#</a> 2.1.4 元组的处理</h2><h3 id="a-创建" tabindex="-1"><a class="header-anchor" href="#a-创建" aria-hidden="true">#</a> a. 创建</h3><p>元组（<code>tuple</code>）也是一种序列类型，其特殊之处在于创建之后不能够修改。</p><p>对于元组的创建，<code>tuple()</code> 函数和<code>()</code>都可以用来创建元组，<strong>甚至可以不用括号</strong>（ python 的打包和拆分，具体见下小节），但是必须有逗号。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 示例</span>
a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token comment"># (1,2)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另一个需要关注的点是，虽然元组本身不能变化，但是<strong>元组内的元素如果是「可变元素」的话，该元素的值是可以修改的</strong>。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment"># 示例</span>
a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">&#39;a&#39;</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&#39;s&#39;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token comment"># (1, [1, &#39;s&#39;, 3], &#39;a&#39;)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="b-赋值的打包和拆分" tabindex="-1"><a class="header-anchor" href="#b-赋值的打包和拆分" aria-hidden="true">#</a> b. 赋值的打包和拆分</h3><p>Python 支持一对称为「打包」和「拆分」的隐式操作。也就是说，只要赋值两边的结构相同，就可以自动地进行元组的打包和拆分。以下为几种例子：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a,b,c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>
<span class="token comment"># a=1  b=2  c=3</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a,<span class="token punctuation">[</span>b,c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>,<span class="token punctuation">(</span><span class="token number">2,3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment"># a=1  b=2  c=3</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a,<span class="token punctuation">(</span>b,c<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>,<span class="token punctuation">(</span><span class="token number">2,3</span><span class="token punctuation">)</span>,4<span class="token punctuation">]</span>
<span class="token comment"># ValueError: too many values to unpack (expected 2)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a,<span class="token punctuation">(</span>b,c<span class="token punctuation">)</span>,d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>,<span class="token punctuation">(</span><span class="token number">2,3</span><span class="token punctuation">)</span>,4<span class="token punctuation">]</span>
<span class="token comment"># a=1  b=2  c=3 d=4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="c-带星号形参" tabindex="-1"><a class="header-anchor" href="#c-带星号形参" aria-hidden="true">#</a> c. 带星号形参</h3><p>带星号形参的本质也是<strong>对于实参的拆分</strong>，这里可以简单理解为：<code>*</code>是对于元组的拆分，<code>**</code>是对于字典的拆分。</p>`,15);function k(v,m){const a=t("RouterLink");return p(),o("div",null,[d,c("p",null,[n("具体的描述请参考："),i(a,{to:"/blog/notion/python/python_book/Chapter%2001/03.html"},{default:l(()=>[n("1.3 逻辑和控制")]),_:1})]),u])}const g=e(r,[["render",k],["__file","01.html.vue"]]);export{g as default};
