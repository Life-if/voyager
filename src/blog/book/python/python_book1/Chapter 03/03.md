---
lang: zh-CN
title: 3.3  生成器函数和闭包
shortTitle: 3.3  生成器函数和闭包
date: 2023-12-04
description: 讨论 python 程序的两种采用函数定义形式构造的编程结构。
index: true
icon: python
category:
  - python
  - 语法基础
tag:
  - 阅读记录
timeline: true
isOriginal: true
star: false
article: true
---

本节讨论的是**生成器函数**得到的**生成器对象**，以及一个称为**闭包**的编程技术。

## 3.3.1 生成器函数

迭代器是一种非常有用的计算结构，也是 Python 语言里的一个核心概念，指一类具有某些特定功能的对象。`for `循环语句依赖于迭代器的概念，一些标准的语言机制可以用于产生选代器，如` range `函数生成迭代器对象。迭代器部分信息可详见：[ 📖2.1.2 可迭代对象部分](../Chapter%2002/01.md)

### a. 定义生成器函数

生成器函数的定义和函数定义基本相同，其关键形式为：
```python
yield 表达式
```
作为生成器对象，最重要的是其 yield 的值而不是返回值。此外，完全可以用一个生成器函数创建多个生成器对象，这些对象相互无关，各自迭代。下面是一个例子：

```python
def read floats(fname):
  infile = open(fname)
  for line in infile:
    for s in line,split():
      yield float(s)
  infile.close()
```

==3.6 生成器yield 语句的扩展形式==

==:送出所有的值之后生成器对象会发出一个信号，该怎么处理?这个问题涉及 3.4 节介绍的异常，==

### b. 生成器函数的语义基础

与函数执行不同的是，生成器对象暂停时还能维护其代码执行状态(下次被唤醒时从哪个位置继续执行)的信息。

新建的生成器对象将从函数的初始状态开始执行，当` for `语句(或描述式)向它要求一个值，或对它调用` next `时，生成器对象就被唤醒执行到下一个` yield `语句，送出一个值后再次休眠，等待着被再次唤醒，并这样重复下去直至结束。

可见，生成器对象是一种定义**数据抽象**的机制。数据抽象包括两个部分：一个部分是生成器对象的内部状态是封装的，外部无法直接访问和操作；另一个部分是它们有自己的内部状态和(由生成器函数定义描述的)活动方式。

### c. 无穷生成器

程序中也可能需要能产生出任意多个值的生成器，称为**无穷生成器**。

Python 允许生成器函数产生“有用的”无穷生成器。可以任意次地将` next `作用于这种生成器，得到任意多个结果。

下面是一个例子：
```python
def circular(seq):
  i=0
  while True:
    yield seq[i]
    i=(i +1)%len(seq)

# 参数 seq 可以是元组或者表，也可以是字符串
```

## 3.3.2 闭包

> 该部分参考了大佬 @风影忍着 的链接：https://zhuanlan.zhihu.com/p/453787908

出于种种原因，我们有时候需要在函数外部得到函数内的局部变量。但是，由于 Python 中作用域的搜索顺序（"链式作用域"结构（chain scope）：子对象会一级一级地向上寻找所有父对象的变量），这一点通常是无法实现的。

但是有一种方法可以实现该需求，那就是在函数的内部，再定义一个函数。从一个函数返回局部函数的技术称为**闭包**技术。（有些地方也叫**工厂函数（factory function）**）下面是一个例子：

```python
def read_floats(fname):
    nlist=[]
    infile = open(fname)
    crt=0
    def next_float():
        nonlocal nlist,crt
        if crt== len(nlist):
            # 一行已经用完
            line = infile.readline()
            if not line:
                #line是空串，整个文件已经处理完
                infile.close()
                return None
            nlist =line.split()
            crt=0
        crt +=1
        return float(nlist[crt - 1])
    # 返回局部定义的函数对象
    return next_float
```
其调用如下

```python
next_number = read_floats("datafile.dat")
for i in range(10):
    print(next_number())
```

维基百科的定义中已经提到的它的两个用处：① 可以读取函数内部的变量，②让这些变量的值始终保持在内存中。

### a. 使用注意点
1. **内存消耗**
由于闭包会使得函数中的变量都被保存在内存中，会增加内存消耗，所以不能滥用闭包，否则会造成程序的性能问题，**可能导致内存泄露**。解决方法是，**在退出函数之前，将不使用的局部变量全部删除。**

2. 闭包无法改变外部函数局部变量指向的内存地址
这点很好理解，即局部变量改变不能影响全局变量，除非加` nonlocal `。

3. 💥❗❗**返回闭包时，返回函数不要引用任何循环变量，或者后续在外部发生变化的变量**
看一个例子：
```python
def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
# 期望 1 4 9 实际 9 9 9
```
这里出现问题是因为：在向列表中添加` func `的时候，` i `的值没有固定到` f `的实例对象中，而仅是将**计算流程**固定到了实例对象中。（换句话说，如果里面写的是` a=i*i `来存储一样没用）。等到了调用`f1()`、`f2()`、`f3()`的时候才去取` i `的值，这时候循环已经结束，` i `的值是3，所以结果都是9。

### b. 底层理解

我们这里分别分析上面给出的两个例子。

对于文件循环读数据的那个例子，有
