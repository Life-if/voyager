---
lang: zh-CN
title: 3.1  基本语义问题
shortTitle: 3.1  基本语义问题
date: 2023-11-30
description: 讨论 python 程序的基本语义问题
index: true
icon: python
category:
  - python
  - 语法基础
tag:
  - 阅读记录
timeline: true
isOriginal: true
star: false
article: true
---

## 3.1.1 变量和对象

这里重点讨论的是变量的赋值的问题。

💢💢看似这里说了一大堆，实际上想说的就是值和地址引用的区别（更确切的说，是逻辑地址和实际地址之间的区别），Python 用的都是地址，所以会出现各种各样的问题，编码的时候需要注意。

---

### a. 值语义与引用语义

变量用于在程序运行中记录信息。为记录信息，每个变量都需要占据或大或小的一块内存。对各种常见语言，主要有两种行为方式。

C 语言的变量是**值的容器**，用于保存相应的值。被保存的值不是独立实体，只是保存在变量(占据的那些**内存单元**里)里的一串二进制码。这一套语义规则称为**变量的值语义**。(也就是实际地址)

采用这种方式一方面存储受到了变量类型的影响，比如` short `需要的字节，等等；另一方面，**由于值存在变量里，变量赋值就是值拷贝**，比如：把变量 x 的值赋给 y ，就是把当保存在变量 x 里的数据复制到变量 y 的内存单元中。

Python 中采用的是另一种方式。。程序运行中存在的“值”都是独立的对象，**每个对象（每个值）有固定的存储位置，有唯一标识，从对象建立起就占据着或大或小的一块内存**。标准函数 id 可以取得对象的标识。(变量存逻辑地址，类似于引用)
```sh
>>> id(3)
2502918498672
```
由上可知，对象标识用一个整数表示。具体对象的标识由解释器安排和控制，可以检查但不能操作。对象有类型，不同对象需要保存的信息有多有少，因此大小可能不同。我们不需要知道具体对象的大小，只需要根据对象的类型正确使用。

此外，如果运行到某个时刻，当时存在的某对象不再有用了，解释器就可能回收其内存。

换而言之，**Python 的赋值采用的是引用语义。** 采用引用的方便之处在于，可以不用定义变量类型。（虽然本人并不认为这是方便！）

::: info
由于变量无类型，解释器不能根据代码中的变量（和表达式）确定操作能否正常进行，必须在运行中检查。

运行中的频繁检查是 Python程序效率较低的一个重要原因。
:::

### b. 赋值和共享

在 Python 引用语义的关联中，对于同一内容，两个变量往往会**关联**到同一个对象。当对象是一个【可变对象】的时候，其影响是灾难性的！！因为当关联统一对象的变量其中一个修改的时候，另一个变量也会随之修改。

以一个例子来进行说明。有如下程序：
```python
a = b = []
c, d = [],[]
```
此时，a 和 b 共享同一个空表，c 和 d 相互无关，也与 a 和 b 无关。而当 a 改变的时候，b也会随之改变。
```sh
>>> a.append(1)
[1]
>>> b
[1]
```
因此需要格外注意【可变类型】与【不可变类型】！！！

另一方面，在引用不同的基础上，` x+=e `（扩展赋值）和` x=x+e `在 C 语言和 Python 中也是不一样的：

1. 第一个问题是扩展赋值语句中左右两边的求值顺序。C 语言对这一顺序不定义，允许实现采用任何顺序。Python 则明确规定先对左边的赋值目标表达式求值，后对右边的表达式(与一般赋值语句不同)求值。

2. 第二个问题在 C 和 Python 里的规定一样：采用扩展赋值运算符时，只对赋值目标做一次求值，而在执行上面用普通赋值运算符写的语句时，赋值目标表达式x将求值两次。如果语句左边或右边的求值有副作用，这两项规定都会产生影响。

3. 第三个问题是 Python 的特殊问题：**在处理扩展赋值操作时，解释器将尽可能“就地”执行操作而不拷贝对象**。如果被赋值目标关联于可变对象，这个规定就会使得上面两种语句的意义完全不同了。（同理于上面的示例程序）

下面是第三点的一个示例，以供参考：
```python
import numpy as np
a=np.array([1,2,3])
b=a
# 此时，a,b共享的是同一个地址，这时可以测试
a+=1     # a=array([2, 3, 4])  b=array([2, 3, 4])
a=a+1    # a=array([3, 4, 5])  b=array([2, 3, 4])
```

### c. 拷贝和循环序列

对于引用语义，如果想要得到完全没有关联的数据，可以采用**拷贝**的方式。其中，只做一层的拷贝方式称为**浅拷贝**，深入多层(例如一直做到不变元素)的拷贝称为**深拷贝**。

:::warning
Python 的标准操作都只做浅拷贝，如果需要深拷贝，可以考虑引入` copy `程序包并调用` deepcopy() `函数。
:::

但是，通过共享可以建立“循环的”表或更复杂的数据结构。比如下面的循环表：
```sh
>>> l1=['ok']
>>> l2=[1]

>>> l1.append(l2)
['ok', [1, [...]]]

>>> l2.append(l1)
[1, ['ok', [...]]]
```
可以看到，Python解释器能识别循环结构，合理地输出和拷贝。但是如果结构中的关联关系很复杂，拷贝操作不保证能正常工作。实际中这种“循环表”很少使用，如果需要“循环”结构，建议用面向对象机制，自己定义。

## 3.1.2 函数和参数语义

由上面的讨论，不难知道如果在函数中，实际上形参与实参之间的赋值也是引用语义。换句话说，**在函数里可以通过参数修改共享的可变对象。**。如果在函数运行中共享参数发生了变化，那么在外部环境中的参数值也会发生变化

Python 运行中的都是独立的对象，函数调用时的参数传递方式类似于值参数，但却是共享传来的对象。这种参数称为**共享参数**。

🍟然而，这里仍然需要对函数默认参数进行强调说明 ❗❗

Python 规定，在函教定义时求值参数的默认值表达式，在内部记录求得的值。一且函数被调用时需要默认值（调用式子没给相应形参提供实参），就**使用记录的值**。

这种规定看起来很合理。但是，由于可变对象和引用的存在，这种规定可能带来很奇怪的效果，如下所示。

```python
def append(a,b=[]):
  ''' 
  把a值添加到列表b中
  '''
  for i in range(5):
    b.append(a)
  return b

append(1,[]) # [1, 1, 1, 1, 1]
append(1)    # [1, 1, 1, 1, 1]
append(2)    # [1, 1, 1, 1, 1, 2, 2, 2, 2, 2]
append(1,[]) # [1, 1, 1, 1, 1]
append(1)    # [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
```
实际上，产生这一情况的原因就是**对象共享和变动性，以及 Python 有关参数默认值表达式的求值规则**，正是这几方面综合作用的结果。

在实际编程中，如果希望函数实际修改调用中提供的表参数，可以采用下面的方法：

```python
def append(a,b=None):
  if b is None:
    b=[]
  for i in range(5):
    b.append(a)
  return b

append(1,[]) # [1, 1, 1, 1, 1]
append(1)    # [1, 1, 1, 1, 1]
append(2)    # [2, 2, 2, 2, 2]
append(1,[]) # [1, 1, 1, 1, 1]
append(1)    # [1, 1, 1, 1, 1]
```
如果不希望函数修改作为实参的表，可以采用下面的技术:

```python
def append(a,b=[]):
  b=list(b)
  for i in range(5):
    b.append(a)
  return b

append(1,[]) # [1, 1, 1, 1, 1]
append(1)    # [1, 1, 1, 1, 1]
append(2)    # [2, 2, 2, 2, 2]
append(1,[]) # [1, 1, 1, 1, 1]
append(1)    # [1, 1, 1, 1, 1]
```

这两种方法都可以避免之前提到的问题。

## 3.1.3  逻辑判断

### a. “同一个” 和 “相等”

在 Python 中存在两种 “相同” 的概念：一种是地址相同，即引用在相同的位置；另一种是含义上的相同，比如两个变量数值大小相同。

:::tip
这里特意没说哪个数值完全一致，因为在 Python 中，完全等同的数值，其地址也是相同的。比如：
```python
a,b=1,1
id(a)    # 140709809761184
id(b)    # 140709809761184
```
这里说的数值相同，可以理解为：1.0 和 1 之间的相同
```python
a,b=1.0,1
id(a)    # 2102044064400
id(b)    # 140709809761184
a==b     # True
```
这类问题是:对于不变对象，两个变量是引用着同一个对象，还是引用着不同对象，对程序行为不会产生有意义的影响。鉴于此，Python 解释器可能做些优化，尽可能少地创建同样不变对象的拷贝。但是尽管如此，还是有很多可能并不相同的情况出现。比如：
```sh
>>> f=2**20
>>> g=4**10
>>> f
1048576
>>> g
1048576
>>> f==g
True
>>> id(f)
2512216291728
>>> id(g)
2512216292080
>>> k=2**20
>>> id(k)
2512218912976
```
从中可以观察到，尽管这种情况下的值是一样的，但是并没有放置在同一个地址。因此不变对象地址的位置不变是没有普遍性的。

另外，不变组合类型(元组和冻结集合)的空对象永远只有一个，空串也只有一个。与此类似，系统常量` True `、` False `和` None `都具有唯一性。这些情况也应该利用。
:::

对于第一种 “相同” 的判断，即检查是否为同一对象，可以采用` is `和` is not `来进行判断；对于第二种 “相同” 的判断，即检查是否是相同大小，可以采用` == `和` != `来判断。

另外需要注意的是，当一个可变对象建立之后，其地址一般就不动了。比如
```python
list1 = [1,2]
while list1 is not []:
  list1.pop()
```
这段程序中，` list1 is not [] ` 永远都是` True `。

### b. "真" 和 "假"

这里需要区分的是，，True/False 以及 “真” 和 “假” 是 Python 中两对不同的概念。前一对是 Python 关键字，表示 bool 类型的两个标准常量；后一对是编程中的概念，服务于逻辑判断和程序控制。

在 [📖 1.3.2 节 ](../Chapter%2001/03.md) 中已经对程序控制和短路原则进行了说明，这里不再赘述。


### c. 序列类型的比较

如果两个序列的类型相同，而且元素可以逐对比较大小，它们就可以比较大小。比较也采用字典序，` s<t `的条件是从下标 0 开始顺序比较对应位置的元素:

+ 如果发现的第一对不同元素在下标i而且s[i]< t[i];

+ 两个序列在可比较的范围内所有元素都相等，但序列 s 较短

两个同类型且元素可比的序列之间，<、==、>三者之一必定成立。注意，<=、<、>、>= 只能用于相同类型的对象。如果作用到不同类型的序列，或者在元素比较时遇到了不同类型（而且无法转换到相同类型）的元素，解释器都将报 TypeError。

### d. 计算顺序

Python 明确规定了运算对象的求值顺序和调用式中实参的求值顺序。二元运算符总先求值其左边的运算对象；函数调用时先求出所需函数对象，而后从左到右逐个求值实参表达式。完成后做实参与形参的匹配，再执行函数体。Python 这样明确规定,就是为了保证表达式意义的确定性。