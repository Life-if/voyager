---
lang: zh-CN
title: 3.2  程序的语义实现
shortTitle: 3.2  程序的语义实现
date: 2023-12-02
description: 讨论 python 程序的基本语义问题
index: true
icon: python
category:
  - python
  - 语法基础
tag:
  - 阅读记录
timeline: true
isOriginal: true
star: false
article: true
---

💣本节讨论的是 Python 的抽象模型，内容有点像编译原理，这里挑重点介绍一下。

## 3.2.1 环境和状态

### a. 环境

在启动 Python 解释器后，环境中就已经对标准函数名和标准类型名有了定义（比如：`True`、`float`、`id`等）。环境启动后就能找到它们和它们的关联值。

如果一个名字在 Python 解释器中没有赋值，也没有定义为函数名，则说这个名字**无定义**。但是一但满足了上面的几点之一就有了定义。这说明 Python 解释器时刻记得哪些名字有定义，这些信息记录在环境中，环境是程序运行的基础。

显然，程序运行的环境可能随着程序中语句的执行而发生变化。环境的功能类似于一个字典，每个名字都有其映射。**如果明确要删除某个已有定义。则可以使用代码` del xxx `来删除` xxx `。` xxx `可以是变量，也可以是可变序列的元素或切片、字典的关联、对象属性等。**

:::danger
千万不要手贱尝试` del `系统内置空间变量，如果不想重装的话。😫
:::

### b. 状态

对环境中有定义的变量，我们能取得其值，而具体得到什么值则由在此之前执行的语句决定。在程序执行中的每个时刻，所有有定义的名字及其关联值，构成了当时的**程序执行状态**(简称**程序状态**或**状态**)。

用前面的比喻，如果环境对应于一个字典，状态就是该字典在某个时刻的具体情况:存在哪些关键码，它们的关联值是什么。

## 3.2.2 程序执行中的环境和状态变化

实际上.造成环境变化的最重要情况是函数调用。

首先应当知道什么是 **命名空间（namespace）**。这个名词在 C++ 中也有重要的作用。简单来说就是记录了一组有定义的名字，是运行时的动态概念（相对于静态概念的【作用域】）。

那么了解了命名空间，就能把环境和环境变化的情况说清楚了。解释器启动建立的初始环境里有一个 **内置命名空间（built-in namespace）**。其中记录了所有准常量名、标准函数名和标准类型名、各种错误的名字，以及它们的关联，再建立一个**全局名字空间**作为当前名字空间(对应于全局作用域)，然后等待用户输入。

标准函数` dir() `返回指定名字空间里的名字(字符串)表，默认为当前名字空间，如在解释器后立刻执行` dir() `，可以看到下面的情况：
```python
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', 
'__package__', '__spec__']
```
其中的` '__builtins__' `就是预定义的内置命名空间。

程序启动后的环境两个空间里有定义的名字都可以使用，但使用有顺序:**先查看当前名字空间**。

```sh{1,6}
>>> print=3
>>> print(3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable
>>> __builtins__.print(print)
3
```

遇到函数调用时，解释器将为其创建一个新的局部名字空间，设定该名字空间与其外围的联系(以被调函数的定义所在作用域的名字空间为外围)。然后把这个新名字空间作为当前名字空间，在新环境中执行函数体。函数退出时抛弃为其建立的名字空间，环境恢复调用前的局面，在恢复的环境中继续执行随后操作。**所以在函数内改变外界值的时候要注意局部作用域和全局作用域的作用范围。**




