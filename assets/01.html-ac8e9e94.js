import{_ as p,r as e,o as t,c as o,a as c,b as n,e as l,w as i,f as s}from"./app-ebd99713.js";const u={},r=s(`<h2 id="_3-1-1-变量和对象" tabindex="-1"><a class="header-anchor" href="#_3-1-1-变量和对象" aria-hidden="true">#</a> 3.1.1 变量和对象</h2><p>这里重点讨论的是变量的赋值的问题。</p><p>💢💢看似这里说了一大堆，实际上想说的就是值和地址引用的区别（更确切的说，是逻辑地址和实际地址之间的区别），Python 用的都是地址，所以会出现各种各样的问题，编码的时候需要注意。</p><hr><h3 id="a-值语义与引用语义" tabindex="-1"><a class="header-anchor" href="#a-值语义与引用语义" aria-hidden="true">#</a> a. 值语义与引用语义</h3><p>变量用于在程序运行中记录信息。为记录信息，每个变量都需要占据或大或小的一块内存。对各种常见语言，主要有两种行为方式。</p><p>C 语言的变量是<strong>值的容器</strong>，用于保存相应的值。被保存的值不是独立实体，只是保存在变量(占据的那些<strong>内存单元</strong>里)里的一串二进制码。这一套语义规则称为<strong>变量的值语义</strong>。(也就是实际地址)</p><p>采用这种方式一方面存储受到了变量类型的影响，比如<code>short</code>需要的字节，等等；另一方面，<strong>由于值存在变量里，变量赋值就是值拷贝</strong>，比如：把变量 x 的值赋给 y ，就是把当保存在变量 x 里的数据复制到变量 y 的内存单元中。</p><p>Python 中采用的是另一种方式。。程序运行中存在的“值”都是独立的对象，<strong>每个对象（每个值）有固定的存储位置，有唯一标识，从对象建立起就占据着或大或小的一块内存</strong>。标准函数 id 可以取得对象的标识。(变量存逻辑地址，类似于引用)</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> id<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">2502918498672</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由上可知，对象标识用一个整数表示。具体对象的标识由解释器安排和控制，可以检查但不能操作。对象有类型，不同对象需要保存的信息有多有少，因此大小可能不同。我们不需要知道具体对象的大小，只需要根据对象的类型正确使用。</p><p>此外，如果运行到某个时刻，当时存在的某对象不再有用了，解释器就可能回收其内存。</p><p>换而言之，<strong>Python 的赋值采用的是引用语义。</strong> 采用引用的方便之处在于，可以不用定义变量类型。（虽然本人并不认为这是方便！）</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>由于变量无类型，解释器不能根据代码中的变量（和表达式）确定操作能否正常进行，必须在运行中检查。</p><p>运行中的频繁检查是 Python程序效率较低的一个重要原因。</p></div><h3 id="b-赋值和共享" tabindex="-1"><a class="header-anchor" href="#b-赋值和共享" aria-hidden="true">#</a> b. 赋值和共享</h3><p>在 Python 引用语义的关联中，对于同一内容，两个变量往往会<strong>关联</strong>到同一个对象。当对象是一个【可变对象】的时候，其影响是灾难性的！！因为当关联统一对象的变量其中一个修改的时候，另一个变量也会随之修改。</p><p>以一个例子来进行说明。有如下程序：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>a <span class="token operator">=</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
c<span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，a 和 b 共享同一个空表，c 和 d 相互无关，也与 a 和 b 无关。而当 a 改变的时候，b也会随之改变。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a.append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此需要格外注意【可变类型】与【不可变类型】！！！</p><p>另一方面，在引用不同的基础上，<code>x+=e</code>（扩展赋值）和<code>x=x+e</code>在 C 语言和 Python 中也是不一样的：</p><ol><li><p>第一个问题是扩展赋值语句中左右两边的求值顺序。C 语言对这一顺序不定义，允许实现采用任何顺序。Python 则明确规定先对左边的赋值目标表达式求值，后对右边的表达式(与一般赋值语句不同)求值。</p></li><li><p>第二个问题在 C 和 Python 里的规定一样：采用扩展赋值运算符时，只对赋值目标做一次求值，而在执行上面用普通赋值运算符写的语句时，赋值目标表达式x将求值两次。如果语句左边或右边的求值有副作用，这两项规定都会产生影响。</p></li><li><p>第三个问题是 Python 的特殊问题：<strong>在处理扩展赋值操作时，解释器将尽可能“就地”执行操作而不拷贝对象</strong>。如果被赋值目标关联于可变对象，这个规定就会使得上面两种语句的意义完全不同了。（同理于上面的示例程序）</p></li></ol><p>下面是第三点的一个示例，以供参考：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
a<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
b<span class="token operator">=</span>a
<span class="token comment"># 此时，a,b共享的是同一个地址，这时可以测试</span>
a<span class="token operator">+=</span><span class="token number">1</span>     <span class="token comment"># a=array([2, 3, 4])  b=array([2, 3, 4])</span>
a<span class="token operator">=</span>a<span class="token operator">+</span><span class="token number">1</span>    <span class="token comment"># a=array([3, 4, 5])  b=array([2, 3, 4])</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="c-拷贝和循环序列" tabindex="-1"><a class="header-anchor" href="#c-拷贝和循环序列" aria-hidden="true">#</a> c. 拷贝和循环序列</h3><p>对于引用语义，如果想要得到完全没有关联的数据，可以采用<strong>拷贝</strong>的方式。其中，只做一层的拷贝方式称为<strong>浅拷贝</strong>，深入多层(例如一直做到不变元素)的拷贝称为<strong>深拷贝</strong>。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>Python 的标准操作都只做浅拷贝，如果需要深拷贝，可以考虑引入<code>copy</code>程序包并调用<code>deepcopy()</code>函数。</p></div><p>但是，通过共享可以建立“循环的”表或更复杂的数据结构。比如下面的循环表：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token assign-left variable">l1</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&#39;ok&#39;</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token assign-left variable">l2</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> l1.append<span class="token punctuation">(</span>l2<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">&#39;ok&#39;</span>, <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> l2.append<span class="token punctuation">(</span>l1<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span>, <span class="token punctuation">[</span><span class="token string">&#39;ok&#39;</span>, <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，Python解释器能识别循环结构，合理地输出和拷贝。但是如果结构中的关联关系很复杂，拷贝操作不保证能正常工作。实际中这种“循环表”很少使用，如果需要“循环”结构，建议用面向对象机制，自己定义。</p><h2 id="_3-1-2-函数和参数语义" tabindex="-1"><a class="header-anchor" href="#_3-1-2-函数和参数语义" aria-hidden="true">#</a> 3.1.2 函数和参数语义</h2><p>由上面的讨论，不难知道如果在函数中，实际上形参与实参之间的赋值也是引用语义。换句话说，<strong>在函数里可以通过参数修改共享的可变对象。</strong>。如果在函数运行中共享参数发生了变化，那么在外部环境中的参数值也会发生变化</p><p>Python 运行中的都是独立的对象，函数调用时的参数传递方式类似于值参数，但却是共享传来的对象。这种参数称为<strong>共享参数</strong>。</p><p>🍟然而，这里仍然需要对函数默认参数进行强调说明 ❗❗</p><p>Python 规定，在函教定义时求值参数的默认值表达式，在内部记录求得的值。一且函数被调用时需要默认值（调用式子没给相应形参提供实参），就<strong>使用记录的值</strong>。</p><p>这种规定看起来很合理。但是，由于可变对象和引用的存在，这种规定可能带来很奇怪的效果，如下所示。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token triple-quoted-string string">&#39;&#39;&#39; 
  把a值添加到列表b中
  &#39;&#39;&#39;</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    b<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">return</span> b

append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># [1, 1, 1, 1, 1, 2, 2, 2, 2, 2]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上，产生这一情况的原因就是<strong>对象共享和变动性，以及 Python 有关参数默认值表达式的求值规则</strong>，正是这几方面综合作用的结果。</p><p>在实际编程中，如果希望函数实际修改调用中提供的表参数，可以采用下面的方法：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">if</span> b <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    b<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">return</span> b

append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># [2, 2, 2, 2, 2]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># [1, 1, 1, 1, 1]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不希望函数修改作为实参的表，可以采用下面的技术:</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  b<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    b<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">return</span> b

append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># [2, 2, 2, 2, 2]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># [1, 1, 1, 1, 1]</span>
append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># [1, 1, 1, 1, 1]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种方法都可以避免之前提到的问题。</p><h2 id="_3-1-3-逻辑判断" tabindex="-1"><a class="header-anchor" href="#_3-1-3-逻辑判断" aria-hidden="true">#</a> 3.1.3 逻辑判断</h2><h3 id="a-同一个-和-相等" tabindex="-1"><a class="header-anchor" href="#a-同一个-和-相等" aria-hidden="true">#</a> a. “同一个” 和 “相等”</h3><p>在 Python 中存在两种 “相同” 的概念：一种是地址相同，即引用在相同的位置；另一种是含义上的相同，比如两个变量数值大小相同。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>这里特意没说哪个数值完全一致，因为在 Python 中，完全等同的数值，其地址也是相同的。比如：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span>
<span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token comment"># 140709809761184</span>
<span class="token builtin">id</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token comment"># 140709809761184</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里说的数值相同，可以理解为：1.0 和 1 之间的相同</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1</span>
<span class="token builtin">id</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token comment"># 2102044064400</span>
<span class="token builtin">id</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token comment"># 140709809761184</span>
a<span class="token operator">==</span>b     <span class="token comment"># True</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这类问题是:对于不变对象，两个变量是引用着同一个对象，还是引用着不同对象，对程序行为不会产生有意义的影响。鉴于此，Python 解释器可能做些优化，尽可能少地创建同样不变对象的拷贝。但是尽管如此，还是有很多可能并不相同的情况出现。比如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token assign-left variable">f</span><span class="token operator">=</span><span class="token number">2</span>**20
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token assign-left variable">g</span><span class="token operator">=</span><span class="token number">4</span>**10
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> f
<span class="token number">1048576</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> g
<span class="token number">1048576</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token assign-left variable">f</span><span class="token operator">==</span>g
True
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> id<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token number">2512216291728</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> id<span class="token punctuation">(</span>g<span class="token punctuation">)</span>
<span class="token number">2512216292080</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token assign-left variable">k</span><span class="token operator">=</span><span class="token number">2</span>**20
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> id<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
<span class="token number">2512218912976</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从中可以观察到，尽管这种情况下的值是一样的，但是并没有放置在同一个地址。因此不变对象地址的位置不变是没有普遍性的。</p><p>另外，不变组合类型(元组和冻结集合)的空对象永远只有一个，空串也只有一个。与此类似，系统常量<code>True</code>、<code>False</code>和<code>None</code>都具有唯一性。这些情况也应该利用。</p></div><p>对于第一种 “相同” 的判断，即检查是否为同一对象，可以采用<code>is</code>和<code>is not</code>来进行判断；对于第二种 “相同” 的判断，即检查是否是相同大小，可以采用<code>==</code>和<code>!=</code>来判断。</p><p>另外需要注意的是，当一个可变对象建立之后，其地址一般就不动了。比如</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">while</span> list1 <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
  list1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段程序中，<code>list1 is not []</code> 永远都是<code>True</code>。</p><h3 id="b-真-和-假" tabindex="-1"><a class="header-anchor" href="#b-真-和-假" aria-hidden="true">#</a> b. &quot;真&quot; 和 &quot;假&quot;</h3><p>这里需要区分的是，，True/False 以及 “真” 和 “假” 是 Python 中两对不同的概念。前一对是 Python 关键字，表示 bool 类型的两个标准常量；后一对是编程中的概念，服务于逻辑判断和程序控制。</p>`,54),d=s('<h3 id="c-序列类型的比较" tabindex="-1"><a class="header-anchor" href="#c-序列类型的比较" aria-hidden="true">#</a> c. 序列类型的比较</h3><p>如果两个序列的类型相同，而且元素可以逐对比较大小，它们就可以比较大小。比较也采用字典序，<code>s&lt;t</code>的条件是从下标 0 开始顺序比较对应位置的元素:</p><ul><li><p>如果发现的第一对不同元素在下标i而且s[i]&lt; t[i];</p></li><li><p>两个序列在可比较的范围内所有元素都相等，但序列 s 较短</p></li></ul><p>两个同类型且元素可比的序列之间，&lt;、==、&gt;三者之一必定成立。注意，&lt;=、&lt;、&gt;、&gt;= 只能用于相同类型的对象。如果作用到不同类型的序列，或者在元素比较时遇到了不同类型（而且无法转换到相同类型）的元素，解释器都将报 TypeError。</p><h3 id="d-计算顺序" tabindex="-1"><a class="header-anchor" href="#d-计算顺序" aria-hidden="true">#</a> d. 计算顺序</h3><p>Python 明确规定了运算对象的求值顺序和调用式中实参的求值顺序。二元运算符总先求值其左边的运算对象；函数调用时先求出所需函数对象，而后从左到右逐个求值实参表达式。完成后做实参与形参的匹配，再执行函数体。Python 这样明确规定,就是为了保证表达式意义的确定性。</p>',6);function k(v,b){const a=e("RouterLink");return t(),o("div",null,[r,c("p",null,[n("在 "),l(a,{to:"/blog/book/python/python_book1/Chapter%2001/03.html"},{default:i(()=>[n("📖 1.3.2 节 ")]),_:1}),n(" 中已经对程序控制和短路原则进行了说明，这里不再赘述。")]),d])}const g=p(u,[["render",k],["__file","01.html.vue"]]);export{g as default};
